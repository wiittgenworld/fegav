<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EPUB to DOCX (Direct Zip Extraction)</title>
    <style>
        body { font-family: -apple-system, sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; background-color: #f4f4f9; color: #333; }
        .container { text-align: center; background: white; padding: 2rem 3rem; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); max-width: 400px; width: 100%; }
        .drop-area { border: 2px dashed #ccc; border-radius: 12px; padding: 40px 20px; background-color: #fafafa; margin-bottom: 20px; cursor: pointer; color: #777; }
        .drop-area:hover { border-color: #007bff; background-color: #f0f8ff; color: #007bff; }
        .custom-upload-btn { display: inline-block; background-color: #007bff; color: white; padding: 12px 30px; border-radius: 6px; cursor: pointer; }
        #status { margin-top: 1.5rem; font-size: 0.9rem; color: #666; word-wrap: break-word;}
        input[type="file"] { display: none; }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>
    <script src="https://unpkg.com/html-docx-js/dist/html-docx.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
</head>
<body>

    <div class="container">
        <h1>EPUB to DOCX</h1>
        <div id="dropZone" class="drop-area">
            <span style="font-size: 3rem; display: block; margin-bottom: 10px;">ðŸ“‚</span>
            <span>Drag & Drop EPUB here</span>
        </div>
        <div>
            <label for="fileInput" class="custom-upload-btn">Select File</label>
            <input type="file" id="fileInput" accept=".epub">
        </div>
        <div id="status">
            <span id="statusText">Waiting for file...</span>
        </div>
    </div>

    <script>
        const fileInput = document.getElementById('fileInput');
        const statusText = document.getElementById('statusText');
        const dropZone = document.getElementById('dropZone');

        // Helper to determine mime type from filename
        function getMimeType(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            if (ext === 'jpg' || ext === 'jpeg') return 'image/jpeg';
            if (ext === 'png') return 'image/png';
            if (ext === 'gif') return 'image/gif';
            if (ext === 'svg') return 'image/svg+xml';
            return 'image/jpeg'; // fallback
        }

        // --- DIRECT ZIP EXTRACTION LOGIC ---
        async function convertImagesToBase64(doc, book) {
            const images = doc.querySelectorAll('img');
            
            for (let img of images) {
                let src = img.getAttribute('src');
                if (!src) continue;

                // Clean up source string
                src = decodeURIComponent(src);
                const filename = src.split('/').pop(); // Get "cover.jpg"

                try {
                    let foundKey = null;

                    // 1. Try to find the file key in the Zip structure by matching the filename
                    // This bypasses complex path resolution issues entirely.
                    for (let key in book.archive.zip.files) {
                        if (key.endsWith(filename)) {
                            foundKey = key;
                            break;
                        }
                    }

                    if (foundKey) {
                        // 2. Direct Zip Extraction (Bypassing ePub.js createUrl)
                        // We ask JSZip directly for the data as a Base64 string
                        const base64Data = await book.archive.zip.file(foundKey).async("base64");
                        
                        // 3. Construct the Data URI
                        const mimeType = getMimeType(foundKey);
                        const dataUri = `data:${mimeType};base64,${base64Data}`;

                        // 4. Update the Image Tag
                        img.setAttribute('src', dataUri);
                        img.setAttribute('width', '500'); 
                        img.style.maxWidth = "100%";
                        
                        // console.log(`Success: Embedded ${filename}`);
                    } else {
                        console.warn(`File not found in archive: ${filename}`);
                    }

                } catch (err) {
                    console.warn(`Error processing image ${src}:`, err);
                }
            }
            return doc;
        }

        const processFile = async (file) => {
            if (!file) return;
            statusText.textContent = "Reading EPUB structure...";
            
            try {
                const buffer = await file.arrayBuffer();
                const book = ePub(buffer);
                await book.ready;

                let fullHtml = `
                    <!DOCTYPE html>
                    <html xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:w='urn:schemas-microsoft-com:office:word'>
                    <head><meta charset='utf-8'><title>${book.package.metadata.title}</title></head>
                    <body>
                `;
                
                const spine = book.spine;

                for (const item of spine.items) {
                    statusText.textContent = `Processing section ${item.index + 1} of ${spine.items.length}...`;

                    try {
                        let doc = await book.load(item.href);

                        if (doc instanceof Document) {
                            // We no longer need chapterHref because we are just hunting by filename
                            await convertImagesToBase64(doc, book);
                            
                            fullHtml += doc.body.innerHTML;
                            fullHtml += '<br style="page-break-after: always;" />';
                        }
                    } catch (e) {
                        console.warn("Skipping chapter:", e);
                    }
                }

                fullHtml += "</body></html>";

                statusText.textContent = "Generating Word document...";
                await new Promise(r => setTimeout(r, 50));

                const converted = htmlDocx.asBlob(fullHtml, {
                    orientation: 'portrait',
                    margins: { top: 720, bottom: 720, left: 720, right: 720 }
                });

                saveAs(converted, file.name.replace(/\.epub$/i, '') + ".docx");
                statusText.textContent = "Done! Download started.";

            } catch (err) {
                console.error(err);
                statusText.textContent = "Error: " + err.message;
            } finally {
                fileInput.value = '';
            }
        };

        fileInput.addEventListener('change', (e) => processFile(e.target.files[0]));
        dropZone.addEventListener('click', () => fileInput.click());
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(e => {
            dropZone.addEventListener(e, (ev) => { ev.preventDefault(); ev.stopPropagation(); });
        });
        dropZone.addEventListener('drop', (e) => processFile(e.dataTransfer.files[0]));
    </script>
</body>
</html>
